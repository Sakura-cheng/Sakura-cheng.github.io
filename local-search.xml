<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解Java虚拟机第2章笔记</title>
    <link href="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Java内存区域与内存溢出异常</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机将内容分为下图的几个部分：</p><p><img src="/深入理解Java虚拟机第2章笔记/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>每个线程都要自己独立的程序计数器</p><p>当执行Java方法时，程序计数器中记录着虚拟机字节码指令的地址</p><p>当执行Native方法时，程序计算器中内容为空（注：Native方法可以理解为不是由Java实现的方法）</p><p>程序计数器是Java虚拟机规范中唯一一个没有规定任何<code>OutOfMemoryError</code>情况的区域</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>和程序计数器一样，虚拟机栈也是每个线程私有的</p><p>生命周期和线程相同，在线程中每个方法执行的同时会创建一个栈帧，用于保存这个方法相关的局部变量表、操作数栈、动态链接、方法出口等信息</p><p>每个方法的执行过程，就对应了这个栈帧在虚拟机栈中的出栈和入栈过程</p><p>两种异常状态：</p><ul><li><code>StackOverflowError</code>：栈溢出</li><li><code>OutOfMemoryError</code>：如果虚拟机可以动态扩展，在扩展时无法申请到足够的内容</li></ul><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表所需的内容空间是在编译期完成分配的，在方法执行过程中大小不改变</p><p>存储了编译期可知的各种基本数据类型、对象引用（<code>reference</code>类型）和<code>returnAddress</code>类型，其中<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间，其余的数据类型只占1个</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈的作用类似于虚拟机栈</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是Java虚拟机管理内存中最大的一块</p><p>是所有线程共享的一块内存区域</p><p>在虚拟机启动时创建</p><p>此内存区域的唯一目的就是存放对象实例</p><p>Java堆是垃圾收集器管理的主要区域</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与Java堆一样，是各个线程共享的内容区域，用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>以HotSpot虚拟机为例探讨在Java堆中对象分配、布局和访问的全过程</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol><li>虚拟机遇到一个new指令时，首先区检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程（具体见第7章）</li><li>在类加载检查通过后，将为新生对象从Java堆中分配内存，对象所需内存的大小在类加载完成后便可完全确定</li><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值</li><li>接下来，虚拟机要对对象进行必要的设置，相关信息存放在对象的对象头中</li><li>这时，从虚拟机的角度看，一个新的对象已经产生了，但从Java程序的角度来看，对象的创建才刚刚开始——<init>方法还没执行，所有的字段都还为零，所有在执行new指令后会接着执行<init>方法，把对象进行初始化，这样一个真正可用的对象才算完全产生出来</init></init></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot虚拟机的对象头包含两部分信息：第一部分用于存储对象自身的运行时数据，第二部分是类型指针，即对象指向它的类元素的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</p><p>如果对象是一个Java数组，那么在对象头中还有一块用于记录数组长度</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据是对象真正存储的有效信息</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>这部分不是必然存在的，没有特别的含义，仅仅起占位符的作用（比如在HotSpot虚拟机中的作用是补全成8字节的倍数）</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序通过栈上的<code>reference</code>数据来操作堆上的具体对象，目前主流的访问方式有使用句柄和直接指针两种</p><ol><li><p>使用句柄：在Java堆中将会划分出一块内存作为句柄池，<code>reference</code>中存储的就是对象的句柄地址，其中包含了对象实例数据和类型数据各自的具体地址信息</p><p><img src="/深入理解Java虚拟机第2章笔记/%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt></p><p>这种方式在对象被移动时，<code>reference</code>本身不需要修改，只需要修改句柄种的实例数据指针</p></li><li><p>直接指针：<code>reference</code>中存储的直接就是对象地址</p><p><img src="/深入理解Java虚拟机第2章笔记/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt></p><p>这种方式的好处是速度快，节省了一次指针定位的时间开销</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在已有win10系统的电脑上安装manjaro构成双系统</title>
    <link href="/%E5%9C%A8%E5%B7%B2%E6%9C%89win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85manjaro%E6%9E%84%E6%88%90%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <url>/%E5%9C%A8%E5%B7%B2%E6%9C%89win10%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85manjaro%E6%9E%84%E6%88%90%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>记录一下在已有win10系统的电脑上安装manjaro构成双系统</p><a id="more"></a><h2 id="下载manjaro"><a href="#下载manjaro" class="headerlink" title="下载manjaro"></a>下载manjaro</h2><p>在<a href="https://manjaro.org/download/" target="_blank" rel="noopener">manjaro官网</a>下载manjaro，或使用<a href="https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/" target="_blank" rel="noopener">国内镜像</a>下载</p><h2 id="创建u盘启动盘"><a href="#创建u盘启动盘" class="headerlink" title="创建u盘启动盘"></a>创建u盘启动盘</h2><p>需要一个空u盘，和<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">UItraISO工具</a>制作u盘启动盘</p><ol><li>文件-&gt;打开，选择下载好的iso文件</li><li>启动-&gt;写入硬盘映像<br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/UItraIso1.png" alt="启动-&gt;写入硬盘映像1"></li><li>选择准备好的空u盘，将写入方式设置为RAW（USB-HDD+方式对manjaro来说在安装时无法识别），点击写入，等待写入完成<br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/UItraIso2.png" alt="启动-&gt;写入硬盘映像2"></li></ol><p>这样，u盘启动盘就制作好了</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>为了构成双系统，需要先将win10系统上分出一个空白分区</p><ol><li>右键”此电脑”，单击”管理”，选择”磁盘管理”<br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/%E5%88%86%E5%8C%BA1.png" alt="分区1"></li><li>右键选择需要压缩的磁盘，点击”压缩卷”，输入压缩空间量，点击”压缩”<br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/%E5%88%86%E5%8C%BA2.png" alt="分区2"></li><li>等待压缩完成后会出现一块未分配的磁盘空间，右键该区域，点击”新建简单卷”，其中需要输入”简单卷大小”，然后一路下一步，直到完成<br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/%E5%88%86%E5%8C%BA3.png" alt="分区3"><br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/%E5%88%86%E5%8C%BA4.png" alt="分区4"><br><img src="/在已有win10系统的电脑上安装manjaro构成双系统/%E5%88%86%E5%8C%BA5.png" alt="分区5"></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="进入BIOS，修改启动项为u盘启动"><a href="#进入BIOS，修改启动项为u盘启动" class="headerlink" title="进入BIOS，修改启动项为u盘启动"></a>进入BIOS，修改启动项为u盘启动</h3><p>重启系统，进入BIOS，各个品牌的电脑进入BIOS的方式不同，请自行查询</p><p>进入BIOS后，将secure boot关闭，在boot选项页中将u盘启动移至第一位，然后等待重启</p><h3 id="manjaro的安装"><a href="#manjaro的安装" class="headerlink" title="manjaro的安装"></a>manjaro的安装</h3><p>根据提示安装即可，记得driver选择nonfree</p><h2 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h2><h3 id="更新镜像源"><a href="#更新镜像源" class="headerlink" title="更新镜像源"></a>更新镜像源</h3><p><code>sudo pacman-mirrors -i -m rank -c China</code></p><p>同步<code>sudo pacman -Syy</code></p><p>更新系统<code>sudo pacman -Syyu</code></p><p>使用root权限编辑<code>/etc/pacman.conf</code>增加以下内容</p><pre><code class="hljs undefined"><span class="hljs-section">[archlinuxcn]</span><span class="hljs-attr">SigLevel</span> = Optional TrustedOnly<span class="hljs-attr">Server</span> =https://mirrors.ustc.edu.cn/archlinuxcn/<span class="hljs-variable">$arch</span></code></pre><p>然后执行<code>sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></p><h3 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h3><p><code>sudo pacman -S fcitx-im (#默认全部安装)</code></p><p><code>sudo pacman -S fcitx-configtool</code></p><p><code>sudo pacman -S fcitx-sogoupinyin (#安装搜狗拼音)</code></p><p>添加配置文件<code>~/.xprofile</code>，输入以下内容</p><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GTK_IM_MODULE</span>=fcitx<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=fcitx<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">"@im=fcitx"</span></code></pre><p>重启</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p><code>sudo pacman -S zsh</code></p><p><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; # 下载并配置ohmyzsh</code></p><p><code>chsh -s /bin/zsh  #更换默认bash，重启后生效</code></p><h4 id="修改zsh主题"><a href="#修改zsh主题" class="headerlink" title="修改zsh主题"></a>修改zsh主题</h4><p>主题文件都存放在<code>~/.oh-my-zsh/themes</code>下，修改<code>~/.zshrc</code>配置文件中的：<code>ZSH_THEME=&quot;你想要的主题&quot;</code></p><p>让配置文件生效：<code>source ~/.zshrc</code></p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p><code>sudo pacman -S vim</code></p><h3 id="AUR助手（以防官方仓库没有想要的软件）"><a href="#AUR助手（以防官方仓库没有想要的软件）" class="headerlink" title="AUR助手（以防官方仓库没有想要的软件）"></a>AUR助手（以防官方仓库没有想要的软件）</h3><p><code>sudo pacman -S yay</code></p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manjaro</tag>
      
      <tag>Linux</tag>
      
      <tag>装系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python标准库之argparse</title>
    <link href="/python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bargparse/"/>
    <url>/python%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bargparse/</url>
    
    <content type="html"><![CDATA[<p>argparse是python的一个用于解析命令行的标准库</p><a id="more"></a><h2 id="一个什么也没实现的例子"><a href="#一个什么也没实现的例子" class="headerlink" title="一个什么也没实现的例子"></a>一个什么也没实现的例子</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.parse_args()</code></pre><p>上面这段代码如果直接执行什么也不做<br><img src="/python标准库之argparse/%E4%BB%80%E4%B9%88%E4%B9%9F%E4%B8%8D%E5%81%9A.png" alt="什么也不做"></p><p>加上<code>--help</code>会输出默认的帮助信息<br><img src="/python标准库之argparse/%E8%BE%93%E5%87%BA%E9%BB%98%E8%AE%A4%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF.png" alt="输出默认帮助信息"></p><h2 id="添加位置参数"><a href="#添加位置参数" class="headerlink" title="添加位置参数"></a>添加位置参数</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">"test"</span>)args = parser.parse_args()print(args.test)</code></pre><p>上面的代码添加了一个命令行参数<code>test</code>，直接执行会报错<br><img src="/python标准库之argparse/%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E4%BC%9A%E6%8A%A5%E9%94%99.png" alt="直接执行会报错"></p><p>带上参数执行会执行输出语句<br><img src="/python标准库之argparse/%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0.png" alt="输出参数"></p><h2 id="为参数提供帮助信息"><a href="#为参数提供帮助信息" class="headerlink" title="为参数提供帮助信息"></a>为参数提供帮助信息</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">"test"</span>, help=<span class="hljs-string">"测试添加一个参数"</span>)args = parser.parse_args()print(args.test)</code></pre><p>在添加参数时，指定<code>help</code>的内容可以给参数添加帮助信息，可通过<code>--help</code>查看<br><img src="/python标准库之argparse/%E4%B8%BA%E5%8F%82%E6%95%B0%E6%B7%BB%E5%8A%A0%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF.png" alt="为参数添加帮助信息"></p><h2 id="指定参数类型"><a href="#指定参数类型" class="headerlink" title="指定参数类型"></a>指定参数类型</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">"number"</span>, help=<span class="hljs-string">"测试添加一个参数"</span>, type=int)args = parser.parse_args()print(args.number + <span class="hljs-number">1</span>)</code></pre><p>如果不给定<code>type</code>指定参数类型，默认是<code>str</code>类型</p><h2 id="添加可选参数"><a href="#添加可选参数" class="headerlink" title="添加可选参数"></a>添加可选参数</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">"-s"</span>, <span class="hljs-string">"--start"</span>, help=<span class="hljs-string">"the start number"</span>, type=int)args = parser.parse_args()<span class="hljs-keyword">if</span> args.start:    print(args.start + <span class="hljs-number">1</span>)</code></pre><p>这里指定了一个可选参数<code>start</code>（缩写为<code>s</code>），若在执行时带上这个参数便会输出+1的值</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">"-s"</span>, <span class="hljs-string">"--start"</span>, help=<span class="hljs-string">"print test"</span>, action=<span class="hljs-string">"store_true"</span>)args = parser.parse_args()<span class="hljs-keyword">if</span> args.start:    print(<span class="hljs-string">'test'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'nothing to do'</span>)</code></pre><p>若添加<code>action=&quot;store_true&quot;</code>，不需要带上参数值，便会执行相应的操作</p>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的排序算法</title>
    <link href="/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>常见的排序算法的原理和Java实现</p><a id="more"></a><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>在序列中选取最小的数将其与首位交换</li><li>在剩余序列中选取最小的数将其与剩余序列的首位交换</li><li>重复第2步直到整个序列排完</li></ol><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n.length; i++) &#123;        <span class="hljs-keyword">int</span> minIndex = i;  <span class="hljs-comment">// 先找到n[i]到n[n.length - 1]中最小的元素</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n.length; j++) &#123;            <span class="hljs-keyword">if</span> (n[j] &lt; n[minIndex]) &#123;                minIndex = j;            &#125;        &#125;        <span class="hljs-keyword">if</span> (minIndex != i) &#123;            <span class="hljs-keyword">int</span> tmp = n[i];  <span class="hljs-comment">// 将最小元素与n[i]交换</span>            n[i] = n[minIndex];            n[minIndex] = tmp;        &#125;    &#125;&#125;</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ol><li>在插入排序过程中认为位于序列左边的是已经排好序的</li><li>将右边剩余序列的第一个元素与左边序列的元素从右到左进行比较，插入到合适的位置</li><li>重复第2步直到整个序列排完</li></ol><p>在第2步插入的过程中，先记录第一个元素的值，若它较小则将大的数向右平移，直到找到合适的位置最后将空位补上</p><h3 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n.length; i++) &#123;        <span class="hljs-keyword">int</span> temp = n[i];        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; n[j]) &#123;  <span class="hljs-comment">// n[i]左边的数是有序的，将n[i]与n[i-1]、n[i-2]...比较</span>            n[j + <span class="hljs-number">1</span>] = n[j];  <span class="hljs-comment">// 若n[i]小则将大的数向右平移</span>            j--;        &#125;        n[j + <span class="hljs-number">1</span>] = temp;  <span class="hljs-comment">// 最后再把空位补上，减少交换次数</span>    &#125;&#125;</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>插入排序其实就是间隔为1的希尔排序，所以希尔排序原理基本和插入排序相同</p><ol><li>将原序列以间隔h分为不同的子序列，对每个子序列做插入排序</li><li>间隔h递减重复第1步直到整个序列排完</li></ol><h3 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-keyword">int</span> h = n.length / <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 希尔排序内部就是插入排序，插入排序本质上是间隔为1的希尔排序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h; i &lt; n.length; i++) &#123;            <span class="hljs-keyword">int</span> temp = n[i];  <span class="hljs-comment">// 将每个子序列看成是大小为2，便于理解</span>            <span class="hljs-keyword">int</span> j = i - h;            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; n[j]) &#123;                n[j + h] = n[j];                j -= h;            &#125;            n[j + h] = temp;        &#125;        h -= <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ol><li>将序列的每个元素看作是一个单独的子序列，将相邻的两个序列合并，在合并的过程中排序</li><li>继续合并相邻的两个序列</li><li>重复第2步直到整个序列排完</li></ol><h3 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (right == left) &#123;  <span class="hljs-comment">// 若只有一个元素什么也不做</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;    mergeSort(n, left, mid);    mergeSort(n, mid + <span class="hljs-number">1</span>, right);    merge(n, left, mid, right);&#125;<span class="hljs-comment">/*** 归并排序中合并两个序列* <span class="hljs-doctag">@param</span> n* <span class="hljs-doctag">@param</span> left* <span class="hljs-doctag">@param</span> mid* <span class="hljs-doctag">@param</span> right*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-keyword">if</span> (n[i] &lt; n[j]) &#123;            tmp[k] = n[i];            i++;        &#125; <span class="hljs-keyword">else</span> &#123;            tmp[k] = n[j];            j++;        &#125;        k++;    &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        tmp[k++] = n[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        tmp[k++] = n[j++];    &#125;    <span class="hljs-comment">// 把数据复制回原序列</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;        n[left++] = tmp[index++];    &#125;&#125;</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><ol><li>在序列中选择一个基准（一般就为最左边的那个）</li><li>将剩余元素与基准值比较，小的放到基准元素左边，大的放到基准元素右边</li><li>再对基准左边和右边两个子序列递归做同样的操作直到整个序列排完</li></ol><h3 id="Java实现-4"><a href="#Java实现-4" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> h = left;  <span class="hljs-comment">// 基准</span>    <span class="hljs-keyword">int</span> index = h + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 从基准右边第一个元素开始</span>    <span class="hljs-keyword">int</span> tmp;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt;= right; i++) &#123;        <span class="hljs-keyword">if</span> (n[i] &lt; n[h]) &#123;  <span class="hljs-comment">// 与基准做比较</span>            tmp = n[i];            n[i] = n[index];            n[index] = tmp;            index++;        &#125;    &#125;    tmp = n[h];  <span class="hljs-comment">// 最后将基准值居中</span>    n[h] = n[index - <span class="hljs-number">1</span>];  <span class="hljs-comment">// index-1指向的是比基准值小的最后一个元素</span>    n[index - <span class="hljs-number">1</span>] = tmp;    h = index - <span class="hljs-number">1</span>;    quickSort(n, left, h - <span class="hljs-number">1</span>);    quickSort(n, h + <span class="hljs-number">1</span>, right);&#125;</code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>堆排序主要是利用大根堆这种数据结构来进行排序</p><p>大根堆是一个满足父节点的值大于子节点值的二叉树</p><ol><li>先用原序列构造一个大根堆</li><li>将大根堆的根节点（也就是序列中最大值）和序列中最后一位交换（即使挑出最大的放在序列未）</li><li>判断根节点与子节点的大小，调整节点使其重新符合大根堆</li><li>对除最后一位元素外的剩余序列重复2、3步骤直到整个序列排完</li></ol><h3 id="Java实现-5"><a href="#Java实现-5" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-keyword">int</span> tmp;    <span class="hljs-keyword">int</span> len = n.length;    <span class="hljs-comment">// 从子树开始生成大根堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (<span class="hljs-keyword">int</span>)(len / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        change(n, len, i);    &#125;    <span class="hljs-comment">// 交换根节点和序列最后一位（每次把最大的排到末尾），判断根节点是否应该下移</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        tmp = n[i];        n[i] = n[<span class="hljs-number">0</span>];        n[<span class="hljs-number">0</span>] = tmp;        len -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 逐步缩小待测序列</span>        change(n, len, <span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-comment">/*** 默认其他节点是符合大根堆的，只是判断根节点小于子节点则下移* <span class="hljs-doctag">@param</span> n* <span class="hljs-doctag">@param</span> len* <span class="hljs-doctag">@param</span> i*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左节点</span>    <span class="hljs-keyword">int</span> right = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 右节点</span>    <span class="hljs-keyword">int</span> largest = i;  <span class="hljs-comment">// 根节点</span>    <span class="hljs-keyword">int</span> tmp;    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; n[largest] &lt; n[left]) &#123;  <span class="hljs-comment">// left &lt; len保证largest节点是非叶子节点</span>        largest = left;    &#125;    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; n[largest] &lt; n[right]) &#123;  <span class="hljs-comment">// right &lt; len保证largest节点是非叶子节点</span>        largest = right;    &#125;    <span class="hljs-keyword">if</span> (largest != i) &#123;        tmp = n[i];        n[i] = n[largest];        n[largest] = tmp;        change(n, len, largest);  <span class="hljs-comment">// 向下递归对子树做同样的操作，直到整个树排完</span>    &#125;&#125;</code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>待排序的元素的值必须限定在一定范围内才能使用计数排序</p><ol><li>构造一个长度为最大元素值+1的数组</li><li>遍历序列，将数组与元素值相同的索引位置的值+1</li><li>遍历数组，若索引位置上的值&gt;1则将索引值依次拷贝至原数组</li></ol><h3 id="Java实现-6"><a href="#Java实现-6" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-comment">// 判断需要多大的数组，长度与序列中的最大值相同</span>    <span class="hljs-keyword">int</span> max = n[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : n) &#123;        <span class="hljs-keyword">if</span> (max &lt; i) &#123;            max = i;        &#125;    &#125;    <span class="hljs-comment">// 创建数组</span>    <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 遍历原序列并计数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : n) &#123;        tmp[i]++;    &#125;    <span class="hljs-comment">// 按顺序拷贝回原数组</span>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.length; i++) &#123;        <span class="hljs-keyword">while</span> (tmp[i] &gt; <span class="hljs-number">0</span>) &#123;            n[index++] = i;            tmp[i]--;        &#125;    &#125;&#125;</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>桶排序的基本思想是将序列分到不同的桶中，对每个桶中的序列排序后再合并成最终的序列</p><ol><li>生成桶</li><li>将序列映射到不同的桶中，每个桶中存放不同范围的元素</li><li>桶内元素排序</li><li>将不同桶中已排序的元素合并</li></ol><h3 id="Java实现-7"><a href="#Java实现-7" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n, <span class="hljs-keyword">int</span> bucketSize)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> maxValue = n[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> minValue = n[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 找到序列中的最大值和最小值，便于后续确定桶的个数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : n) &#123;        <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;            maxValue = value;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minValue &gt; value) &#123;            minValue = value;        &#125;    &#125;    <span class="hljs-comment">// 生成桶</span>    <span class="hljs-keyword">int</span> bucketCount = (maxValue - minValue + <span class="hljs-number">1</span>) / bucketSize;    <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 将序列中的元素映射到不同的桶中</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n.length; i++) &#123;        <span class="hljs-keyword">int</span> index = (n[i] - minValue) / bucketSize;        buckets[index] = arrApand(buckets[index], n[i]);    &#125;    <span class="hljs-comment">// 桶内排序</span>    <span class="hljs-keyword">int</span> nindex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;        <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 这里使用快排</span>        quickSort(bucket, <span class="hljs-number">0</span>, bucket.length - <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;            n[nindex++] = value;        &#125;    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] arrApand(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;    arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);    arr[arr.length - <span class="hljs-number">1</span>] = value;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>实质上是从低到高按每一位的计数排序的结果进行排序</p><ol><li>先找到序列中最大元素的位数</li><li>构造桶</li><li>只看最低位，按大小分入不同的桶中</li><li>按顺序拷贝到原序列</li><li>将第3步排好的序列当作新的序列只看次低位，再次按大小分入不同的桶中</li><li>按顺序拷贝到原序列</li><li>依次类推单独比较每一位直到整个序列排完</li></ol><h3 id="Java实现-8"><a href="#Java实现-8" class="headerlink" title="Java实现"></a>Java实现</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] n)</span> </span>&#123;    <span class="hljs-comment">// 先找出序列中最大值位数</span>    <span class="hljs-keyword">int</span> maxValue = n[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : n) &#123;        <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;            maxValue = value;        &#125;    &#125;    <span class="hljs-keyword">int</span> maxNumberLength = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 最大位数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num = maxValue; num != <span class="hljs-number">0</span>; num /= <span class="hljs-number">10</span>) &#123;        maxNumberLength++;    &#125;    <span class="hljs-keyword">if</span> (maxValue == <span class="hljs-number">0</span>) &#123;        maxNumberLength = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxNumberLength; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;        <span class="hljs-keyword">int</span> index;        <span class="hljs-comment">// 比较不同的位时创建新的桶，0-9装负数，10到19装正数，0-9装负数，10到19装正数</span>        <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n.length; j++) &#123;            index = (n[j] % mod) / dev + mod;            buckets[index] = arrApand(buckets[index], n[j]);        &#125;        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;                n[pos++] = value;            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] arrAppand(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;    arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);    arr[arr.length - <span class="hljs-number">1</span>] = value;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python3利用venv和pip管理虚拟环境</title>
    <link href="/python3%E5%88%A9%E7%94%A8venv%E5%92%8Cpip%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/python3%E5%88%A9%E7%94%A8venv%E5%92%8Cpip%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>以前一直不重视python项目的包管理，在交接时总是不明确项目具体需要依赖哪些第三方库，为此复习一下python3虚拟环境的创建和包管理，希望以后能养成一个项目一个环境的习惯</p><a id="more"></a><h2 id="使用venv创建虚拟环境"><a href="#使用venv创建虚拟环境" class="headerlink" title="使用venv创建虚拟环境"></a>使用venv创建虚拟环境</h2><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p>venv是python3标准库中内置的模块，功能和以前的virtualenv类似</p><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>在项目根目录下</p><pre><code class="hljs undefined">python -m venv <span class="hljs-keyword">my</span>-venv</code></pre><p>my-venv是创建的虚拟环境的名字，可以自由修改，执行命令后在项目根目录下会创建对应虚拟环境的文件夹</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><p>在项目根目录下</p><p>windows:</p><pre><code class="hljs undefined"><span class="hljs-keyword">my</span>-venv\scripts\<span class="hljs-built_in">activate</span></code></pre><p>linux:</p><pre><code class="hljs undefined">source <span class="hljs-keyword">my</span>-venv/bin/<span class="hljs-built_in">activate</span></code></pre><p>或</p><pre><code class="hljs undefined">. <span class="hljs-keyword">my</span>-venv/bin/<span class="hljs-built_in">activate</span></code></pre><p>激活虚拟环境后能在命令行提示符前面看见当前虚拟环境的名字</p><pre><code class="hljs undefined">(<span class="hljs-keyword">my</span>-venv) $</code></pre><h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><pre><code class="hljs undefined">(<span class="hljs-keyword">my</span>-venv) $ deactivate</code></pre><h2 id="依赖的导出和导入"><a href="#依赖的导出和导入" class="headerlink" title="依赖的导出和导入"></a>依赖的导出和导入</h2><p>在激活的虚拟环境中依赖的安装和卸载这里就不赘述了</p><p>查看环境中的所有依赖：</p><pre><code class="hljs undefined">(<span class="hljs-keyword">my</span>-venv) $ pip <span class="hljs-built_in">list</span></code></pre><p>导出依赖列表</p><pre><code class="hljs undefined">(<span class="hljs-keyword">my</span>-venv) $ pip freeze &gt; requirements.txt</code></pre><p>安装requirements.txt中所有依赖</p><pre><code class="hljs undefined">(<span class="hljs-keyword">my</span>-venv) $ pip install -r requirements.txt</code></pre>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>venv</tag>
      
      <tag>虚拟环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客的迁移</title>
    <link href="/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <url>/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p>前两天刚<a href https: www.baidu.com"">利用hexo+github搭建静态博客</a>，今天想到以后如果换电脑，肯定是需要将hexo博客进行迁移的，于是便查阅了相关教程，在此做一个记录</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>整个方法的思路是在博客原有的库中新建一个hexo分支来存放hexo生成的文件，而原有的master分支只用来存储hexo部署后的静态文件</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>先从远端将yourname.github.io库clone下来</p><pre><code class="hljs undefined">git clone git@github<span class="hljs-selector-class">.com</span>:yourname/yourname<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span></code></pre><p>打开git bash新建一个hexo分支</p><pre><code class="hljs undefined">git branch hexo  <span class="hljs-comment">// 创建hexo分支</span>git checkout hexo  <span class="hljs-comment">// 跳转到hexo分支</span></code></pre><p>在hexo分支下进行hexo的安装和博客的搭建(<a href https: www.baidu.com"">见此</a>)</p><p>在新建博文后先将hexo文件push到远端(此时是在hexo分支下进行)</p><pre><code class="hljs undefined"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add </span>.<span class="hljs-symbol">git</span> commit -m <span class="hljs-string">""</span><span class="hljs-symbol">git</span> <span class="hljs-keyword">push </span>origin hexo</code></pre><p>再进行静态文件的推送</p><pre><code class="hljs undefined"><span class="hljs-attribute">hexo d</span></code></pre><p>由于之前在站点配置文件_config.yml中设置的分支为master，而hexo文件是在hexo分支上的，两者不会相互影响</p><blockquote><p>deploy:<br>&nbsp;&nbsp;&nbsp;&nbsp;type: git<br>&nbsp;&nbsp;&nbsp;&nbsp;repo: <a href="https://github.com/Sakura-cheng/Sakura-cheng.github.io.git" target="_blank" rel="noopener">https://github.com/Sakura-cheng/Sakura-cheng.github.io.git</a><br>&nbsp;&nbsp;&nbsp;&nbsp;branch: master</p></blockquote><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>当换新电脑时，只需将hexo分支上存放的hexo文件clone下来，再进行相应的hexo和相关插件的安装就行了(注意：这时就不需要执行hexo init命令进行初始化了)</p>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用hexo+github搭建静态博客</title>
    <link href="/%E5%88%A9%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/%E5%88%A9%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>从零开始搭建博客</p><a id="more"></a><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">下载node.js</a></p><p>安装完成后会附带npm包管理器</p><p>为了防止后续下载速度过慢，使用淘宝镜像</p><pre><code class="hljs undefined"><span class="hljs-built_in">npm</span> install -g cnpm --registry=https:<span class="hljs-regexp">//</span>registry.<span class="hljs-built_in">npm</span>.taobao.org</code></pre><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><pre><code class="hljs undefined">cnpm install -g hexo-<span class="hljs-keyword">cli</span></code></pre><h2 id="生成博客"><a href="#生成博客" class="headerlink" title="生成博客"></a>生成博客</h2><p>先创建一个blog文件夹</p><pre><code class="hljs undefined">hexo <span class="hljs-keyword">init</span> <span class="hljs-comment">// 生成博客</span>hexo s <span class="hljs-comment">// 启动博客</span></code></pre><h2 id="写一篇博文"><a href="#写一篇博文" class="headerlink" title="写一篇博文"></a>写一篇博文</h2><pre><code class="hljs undefined">hexo <span class="hljs-built_in">n</span> <span class="hljs-string">"我的第一篇文章"</span></code></pre><p>编写完一篇博文后</p><pre><code class="hljs undefined">hexo clean <span class="hljs-comment">// 清理缓存</span>hexo g <span class="hljs-comment">// 生成</span></code></pre><h2 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h2><pre><code class="hljs undefined">cnpm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save hexo-deployer-git</span></code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改blog目录下的_config.yml文件</p><p>将_config.yml文件最底部修改为：  </p><blockquote><p>deploy:<br>&nbsp;&nbsp;&nbsp;&nbsp;type: git<br>&nbsp;&nbsp;&nbsp;&nbsp;repo: <a href="https://github.com/Sakura-cheng/Sakura-cheng.github.io.git" target="_blank" rel="noopener">https://github.com/Sakura-cheng/Sakura-cheng.github.io.git</a><br>&nbsp;&nbsp;&nbsp;&nbsp;branch: master</p></blockquote><h2 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h2><pre><code class="hljs undefined"><span class="hljs-attribute">hexo d</span></code></pre><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><pre><code class="hljs undefined">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/iissnan/hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span></code></pre><p>修改_config.yml文件中</p><blockquote><p>theme: next</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>备忘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
