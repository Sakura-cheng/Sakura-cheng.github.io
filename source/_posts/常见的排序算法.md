---
title: 常见的排序算法
date: 2019-10-12 16:45:00
categories: 
 - study
tags:
 - 排序
 - Java
---
常见的排序算法的原理和Java实现
<!-- more -->
## 选择排序

### 原理
1. 在序列中选取最小的数将其与首位交换
2. 在剩余序列中选取最小的数将其与剩余序列的首位交换
3. 重复第2步直到整个序列排完

### Java实现
```java
public static void selectionSort(int[] n) {
    for (int i = 0; i < n.length; i++) {
        int minIndex = i;  // 先找到n[i]到n[n.length - 1]中最小的元素
        for (int j = i + 1; j < n.length; j++) {
            if (n[j] < n[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            int tmp = n[i];  // 将最小元素与n[i]交换
            n[i] = n[minIndex];
            n[minIndex] = tmp;
        }
    }
}
```

## 插入排序
### 原理
1. 在插入排序过程中认为位于序列左边的是已经排好序的
2. 将右边剩余序列的第一个元素与左边序列的元素从右到左进行比较，插入到合适的位置
3. 重复第2步直到整个序列排完

在第2步插入的过程中，先记录第一个元素的值，若它较小则将大的数向右平移，直到找到合适的位置最后将空位补上
### Java实现
```java
public static void insertionSort(int[] n) {
    for (int i = 1; i < n.length; i++) {
        int temp = n[i];
        int j = i - 1;
        while (j >= 0 && temp < n[j]) {  // n[i]左边的数是有序的，将n[i]与n[i-1]、n[i-2]...比较
            n[j + 1] = n[j];  // 若n[i]小则将大的数向右平移
            j--;
        }
        n[j + 1] = temp;  // 最后再把空位补上，减少交换次数
    }
}
```

## 希尔排序
### 原理
插入排序其实就是间隔为1的希尔排序，所以希尔排序原理基本和插入排序相同

1. 将原序列以间隔h分为不同的子序列，对每个子序列做插入排序
2. 间隔h递减重复第1步直到整个序列排完

### Java实现
```java
public static void shellSort(int[] n) {
    int h = n.length / 2;
    while (h > 0) {  // 希尔排序内部就是插入排序，插入排序本质上是间隔为1的希尔排序
        for (int i = h; i < n.length; i++) {
            int temp = n[i];  // 将每个子序列看成是大小为2，便于理解
            int j = i - h;
            while (j >= 0 && temp < n[j]) {
                n[j + h] = n[j];
                j -= h;
            }
            n[j + h] = temp;
        }
        h -= 1;
    }
}
```

## 归并排序
### 原理
1. 将序列的每个元素看作是一个单独的子序列，将相邻的两个序列合并，在合并的过程中排序
2. 继续合并相邻的两个序列
3. 重复第2步直到整个序列排完

### Java实现
```java
public static void mergeSort(int[] n, int left, int right) {
    if (right == left) {  // 若只有一个元素什么也不做
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(n, left, mid);
    mergeSort(n, mid + 1, right);
    merge(n, left, mid, right);
}

/**
* 归并排序中合并两个序列
* @param n
* @param left
* @param mid
* @param right
*/
private static void merge(int[] n, int left, int mid, int right) {
    int i = left;
    int j = mid + 1;
    int k = 0;
    int[] tmp = new int[right - left + 1];
    while (i <= mid && j <= right) {
        if (n[i] < n[j]) {
            tmp[k] = n[i];
            i++;
        } else {
            tmp[k] = n[j];
            j++;
        }
        k++;
    }
    while (i <= mid) {
        tmp[k++] = n[i++];
    }
    while (j <= right) {
        tmp[k++] = n[j++];
    }
    // 把数据复制回原序列
    int index = 0;
    while(left <= right) {
        n[left++] = tmp[index++];
    }
}
```

## 快速排序
### 原理
1. 在序列中选择一个基准（一般就为最左边的那个）
2. 将剩余元素与基准值比较，小的放到基准元素左边，大的放到基准元素右边
3. 再对基准左边和右边两个子序列递归做同样的操作直到整个序列排完

### Java实现
```java
public static void quickSort(int[] n, int left, int right) {
    if (left >= right) {
        return;
    }
    int h = left;  // 基准
    int index = h + 1;  // 从基准右边第一个元素开始
    int tmp;
    for (int i = index; i <= right; i++) {
        if (n[i] < n[h]) {  // 与基准做比较
            tmp = n[i];
            n[i] = n[index];
            n[index] = tmp;
            index++;
        }
    }
    tmp = n[h];  // 最后将基准值居中
    n[h] = n[index - 1];  // index-1指向的是比基准值小的最后一个元素
    n[index - 1] = tmp;
    h = index - 1;

    quickSort(n, left, h - 1);
    quickSort(n, h + 1, right);
}
```

## 堆排序
### 原理
堆排序主要是利用大根堆这种数据结构来进行排序

大根堆是一个满足父节点的值大于子节点值的二叉树

1. 先用原序列构造一个大根堆
2. 将大根堆的根节点（也就是序列中最大值）和序列中最后一位交换（即使挑出最大的放在序列未）
3. 判断根节点与子节点的大小，调整节点使其重新符合大根堆
4. 对除最后一位元素外的剩余序列重复2、3步骤直到整个序列排完

### Java实现
```java
public static void heapSort(int[] n) {
    int tmp;
    int len = n.length;
    // 从子树开始生成大根堆
    for (int i = (int)(len / 2) - 1; i >= 0; i--) {
        change(n, len, i);
    }

    // 交换根节点和序列最后一位（每次把最大的排到末尾），判断根节点是否应该下移
    for (int i = len - 1; i > 0; i--) {
        tmp = n[i];
        n[i] = n[0];
        n[0] = tmp;
        len -= 1;  // 逐步缩小待测序列
        change(n, len, 0);
    }
}

/**
* 默认其他节点是符合大根堆的，只是判断根节点小于子节点则下移
* @param n
* @param len
* @param i
*/
private static void change(int[] n, int len, int i) {
    int left = i * 2 + 1;  // 左节点
    int right = i * 2 + 2;  // 右节点
    int largest = i;  // 根节点
    int tmp;

    if (left < len && n[largest] < n[left]) {  // left < len保证largest节点是非叶子节点
        largest = left;
    }
    if (right < len && n[largest] < n[right]) {  // right < len保证largest节点是非叶子节点
        largest = right;
    }
    if (largest != i) {
        tmp = n[i];
        n[i] = n[largest];
        n[largest] = tmp;
        change(n, len, largest);  // 向下递归对子树做同样的操作，直到整个树排完
    }
}
```

## 计数排序
### 原理
待排序的元素的值必须限定在一定范围内才能使用计数排序
1. 构造一个长度为最大元素值+1的数组
2. 遍历序列，将数组与元素值相同的索引位置的值+1
3. 遍历数组，若索引位置上的值>1则将索引值依次拷贝至原数组

### Java实现
```java
public static void countingSort(int[] n) {
    // 判断需要多大的数组，长度与序列中的最大值相同
    int max = n[0];
    for (int i : n) {
        if (max < i) {
            max = i;
        }
    }
    // 创建数组
    int[] tmp = new int[max + 1];
    // 遍历原序列并计数
    for (int i : n) {
        tmp[i]++;
    }
    // 按顺序拷贝回原数组
    int index = 0;
    for (int i = 0; i < tmp.length; i++) {
        while (tmp[i] > 0) {
            n[index++] = i;
            tmp[i]--;
        }
    }
}
```

## 桶排序
### 原理
桶排序的基本思想是将序列分到不同的桶中，对每个桶中的序列排序后再合并成最终的序列

1. 生成桶
2. 将序列映射到不同的桶中，每个桶中存放不同范围的元素
3. 桶内元素排序
4. 将不同桶中已排序的元素合并

### Java实现
```java
public static void bucketSort(int[] n, int bucketSize) {
    if (n.length == 0) return;
    int maxValue = n[0];
    int minValue = n[0];

    // 找到序列中的最大值和最小值，便于后续确定桶的个数
    for (int value : n) {
        if (maxValue < value) {
            maxValue = value;
        } else if (minValue > value) {
            minValue = value;
        }
    }

    // 生成桶
    int bucketCount = (maxValue - minValue + 1) / bucketSize;
    int[][] buckets = new int[bucketCount][0];

    // 将序列中的元素映射到不同的桶中
    for (int i = 0; i < n.length; i++) {
        int index = (n[i] - minValue) / bucketSize;
        buckets[index] = arrApand(buckets[index], n[i]);
    }

    // 桶内排序
    int nindex = 0;
    for (int[] bucket : buckets) {
        if (bucket.length <= 0) {
            continue;
        }
        // 这里使用快排
        quickSort(bucket, 0, bucket.length - 1);
        for (int value : bucket) {
            n[nindex++] = value;
        }
    }
}

private static int[] arrApand(int[] arr, int value) {
    arr = Arrays.copyOf(arr, arr.length + 1);
    arr[arr.length - 1] = value;
    return arr;
}
```

## 基数排序
### 原理
实质上是从低到高按每一位的计数排序的结果进行排序
1. 先找到序列中最大元素的位数
2. 构造桶
3. 只看最低位，按大小分入不同的桶中
4. 按顺序拷贝到原序列
5. 将第3步排好的序列当作新的序列只看次低位，再次按大小分入不同的桶中
6. 按顺序拷贝到原序列
7. 依次类推单独比较每一位直到整个序列排完

### Java实现
```java
public static void radixSort(int[] n) {
    // 先找出序列中最大值位数
    int maxValue = n[0];
    for (int value : n) {
        if (value > maxValue) {
            maxValue = value;
        }
    }
    int maxNumberLength = 0;  // 最大位数
    for (int num = maxValue; num != 0; num /= 10) {
        maxNumberLength++;
    }
    if (maxValue == 0) {
        maxNumberLength = 1;
    }

    int mod = 10;
    int dev = 1;
    for (int i = 0; i < maxNumberLength; i++, dev *= 10, mod *= 10) {
        int index;
        // 比较不同的位时创建新的桶，0-9装负数，10到19装正数，0-9装负数，10到19装正数
        int[][] buckets = new int[mod * 2][0];
        for (int j = 0; j < n.length; j++) {
            index = (n[j] % mod) / dev + mod;
            buckets[index] = arrApand(buckets[index], n[j]);
        }

        int pos = 0;
        for (int[] bucket : buckets) {
            for (int value : bucket) {
                n[pos++] = value;
            }
        }
    }
}

private static int[] arrAppand(int[] arr, int value) {
    arr = Arrays.copyOf(arr, arr.length + 1);
    arr[arr.length - 1] = value;
    return arr;
}
```